#입력값을 받아주고 
N = int(input())
A = list(map(int, input().split()))
#dp 테이블을 만들어서 값을 구해보자
dp = [1] * N

#처음에 수의 크기 1001을 넣고 돌리니 index 에러 발생
for i in range(1, N) :
    for j in range(i) :
        #만약 다음값이 전의 값보다 크다면(증가수열)
        if A[i] > A[j] :
            #A[i]보다 작은 위치에 있는 것들 중 dp 테이블 값이 제일 큰 값으로 바꿔준다.
            #A[i]가  어떤 증가부분수열의 마지막 값이 되기 위해서 A[i]가 추가되기 전 증가부분 수열의 마지막 값이 A[i]보다 작은 값이여야 한다.
            #따라서 A[i]를 마지막 값으로 가지는 가장 긴 증가부분수열의 길이는 A[i]가 추가될 수 있는 증가부분수열 중 가장 긴 수열의 길이에 1을 더한 값이 된다.
            dp[i] = max(dp[i], dp[j]+1)

#dp테이블 중에 최댓값을 출력하면 정답이 나온다.
print(max(dp))

#상세한 설명
# A=[10,20, 10, 30, 20, 50] dP=[1,1,1,1,1]
# - i = 1, j = 0
# 1. A[1] > A[0] 크므로 dp = [1, 1, 1, 1, 1, 1] => [1, 2, 1, 1, 1, 1]

# - i = 2, j = 0, 1
# 1. A[2] < A[0] 
# 2. A[2] < A[1] dp = [1, 2, 1, 1, 1, 1]  2의 값이 0과 1보다 작으므로 리스트의 값들은 변하지 않는다.

# - i = 3, j = 0, 1, 2
# 1. A[3] > A[0] 
# 2. A[3] > A[1]
# 3. A[3] > A[2] dp = [1, 2, 1, 3, 1, 1] 제일 큰 수 = (2 + 1) = 3이 A[3]에 들어간다.

# - i = 4, j = 0, 1, 2, 3
# 1. A[4] > A[0] 
# 2. A[4] < A[1]
# 3. A[4] > A[2] 
# 4. A[4] < A[3] dp = [1, 2, 1, 3, 1, 1,] => [1, 2, 1, 3, 2, 1]

# - i = 5, j = 0, 1, 2, 3, 4
# 1. A[5] > A[0] 
# 2. A[5] > A[1]
# 3. A[5] > A[2] 
# 4. A[5] > A[3]
# 5. A[5] > A[4] dp = [1, 2, 1, 3, 2, 1] => [1, 2, 1, 3, 2, 4]
# 최종 값 max(dp) = 4

